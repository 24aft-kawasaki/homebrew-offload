#!/usr/bin/env python3

import argparse
import json
import logging
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import TypedDict

class Config(TypedDict):
    offload_cellar: str
    offloaded_formulae: list[str]

class ConfigDecodeError(json.JSONDecodeError):
    pass

class BrewOffload:
    DEFAULT_TARGET_PATH = Path.home() / ".offload"

    def __init__(self, args: list[str]) -> None:
        self.log = logging.getLogger(__name__)

        self.args = arg_parse(*args)

        self.brew_cellar_path = self.get_brew_cellar_path()
        self.config_path = self.get_brew_prefix_path() / "etc/brew-offload/config.json"
        # TODO: To test, file access must not be called, if original brew is executed.
        # Plese refactor with test codes.
        self.target_path = self.DEFAULT_TARGET_PATH
        config = self.load_config()
        if "offload_cellar" in config:
            self.target_path = Path(config["offload_cellar"])
    
    @classmethod
    def load_config(cls) -> Config:
        config_path = cls.get_brew_prefix_path() / "etc/brew-offload/config.json"
        with open(config_path, "rt") as config_file:
            try:
                config = json.load(config_file)
            except json.JSONDecodeError as e:
                raise ConfigDecodeError(
                    "Failed to decode brew-offload config file.",
                    e.doc, e.pos
                ) from e
        return config
    
    @classmethod
    def dump_config(cls, config: Config) -> None:
        config_path = cls.get_brew_prefix_path() / "etc/brew-offload/config.json"
        with open(config_path, "wt") as config_file:
            json.dump(config, config_file)

    @staticmethod
    def get_brew_cellar_path() -> Path:
        result = subprocess.run(
            ["brew", "--cellar"],
            capture_output=True, text=True, check=True
        )
        return Path(result.stdout.strip())

    @staticmethod
    def get_brew_prefix_path() -> Path:
        result = subprocess.run(
            ["brew", "--prefix"],
            capture_output=True, text=True, check=True
        )
        return Path(result.stdout.strip())

    def execute(self) -> int:
        if self.args.offload is False:
            return self.execute_original_brew(self.args.original_brew_args)
        elif self.args.subcommand == "add":
            return self.add()
        elif self.args.subcommand == "remove":
            raise NotImplementedError("Remove functionality is not implemented yet.")
        elif self.args.subcommand == "config":
            return self.config()
        return 1
    
    def init_config_file(self) -> int:
        if not self.config_path.exists(follow_symlinks=True):
            self.config_path.touch()
        config: Config = {
            "offload_cellar": str(self.DEFAULT_TARGET_PATH),
            "offloaded_formulae": []
        }
        try:
            config = self.load_config()
            if "offloaded_formulae" in config:
                return 0
        except ConfigDecodeError:
            pass
        self.dump_config(config)
        return 0

    
    def add(self) -> int:
        self.init_config_file()
        config = self.load_config()
        if self.args.formula in config["offloaded_formulae"]:
            self.log.error(f"Formula '{self.args.formula}' is already offloaded.")
            return 1
        config["offloaded_formulae"].append(self.args.formula)
        self.dump_config(config)

        return self.sync()

    def config(self) -> int:
        self.init_config_file()
        config = self.load_config()
        if self.args.key == "offload_cellar":
            new_offload_cellar = Path(self.args.value)
            old_offload_cellar = self.target_path
            if not new_offload_cellar.absolute():
                self.log.error("Offload cellar path must be absolute.")
                return 1
            new_offload_cellar = new_offload_cellar.absolute()
            if not new_offload_cellar.exists():
                self.log.error("Offload cellar path does not exist.")
                return 1
            config["offload_cellar"] = str(new_offload_cellar)
            self.target_path = new_offload_cellar
            self.dump_config(config)
        
            self.mv_offload_cellar(new_offload_cellar, old_offload_cellar)
        return 0

    def sync(self) -> int:
        config = self.load_config()

        # offloading
        for target_formula in config["offloaded_formulae"]:
            src = (self.brew_cellar_path / target_formula).absolute()
            dst = (self.target_path / target_formula).absolute()

            if src.is_symlink() and src.resolve().is_dir():
                continue
            if not src.exists():
                continue
            self.log.info(f"Offloading formula: {target_formula}")
            shutil.copytree(src, dst,
                symlinks=True, dirs_exist_ok=True)
            shutil.rmtree(src)
            os.symlink(dst, src, target_is_directory=True)

        # onloading
        for offloaded in self.target_path.iterdir():
            if offloaded.name in config["offloaded_formulae"]:
                continue
            self.log.info(f"Onloading formula: {offloaded.name}")
            dst = (self.brew_cellar_path / offloaded.name).absolute()
            src = (self.target_path / offloaded.name).absolute()
            dst.unlink()
            shutil.copytree(src, dst, 
                symlinks=True, dirs_exist_ok=True)
            shutil.rmtree(src)

        return 0
    
    def mv_offload_cellar(self, new_cellar: Path, old_cellar: Path) -> int:
        for formula in old_cellar.iterdir():
            src = formula.absolute()
            dst = new_cellar / formula.name
            self.log.info(f"Moving offload cellar formula: {formula.name}")
            shutil.copytree(src, dst)
        config = self.load_config()
        for formula in config["offloaded_formulae"]:
            symlink = self.brew_cellar_path / formula
            symlink.unlink()
            os.symlink(new_cellar / formula, symlink, target_is_directory=True)
        for formula in old_cellar.iterdir():
            shutil.rmtree(formula.absolute())
        return 0

    def execute_original_brew(self, original_brew_args: list[str]) -> int:
        completedProcess = subprocess.run(
            ["brew"] + original_brew_args,
            stdout=None, stderr=None
        )

        return completedProcess.returncode

        

def arg_parse(*args: str) -> argparse.Namespace:
    if args[1:] and args[1] == "wrapped":
        if args[2:] and args[2] == "offload":
            prog = "brew offload"
            remainder = args[3:]
        else:
            result = argparse.Namespace()
            result.offload = False
            result.original_brew_args = list(args[2:])
            return result
    else:
        prog = "brew-offload"
        remainder = args[1:]

    parser = argparse.ArgumentParser(prog=prog)
    subparsers = parser.add_subparsers(title="subcommands")
    add_parser = subparsers.add_parser("add")
    add_parser.set_defaults(subcommand="add")
    add_parser.add_argument("formula")
    remove_parser = subparsers.add_parser("remove")
    remove_parser.set_defaults(subcommand="remove")
    remove_parser.add_argument("formula")
    config_parser = subparsers.add_parser("config")
    config_parser.set_defaults(subcommand="config")
    config_parser.add_argument("key", choices=["offload_cellar"])
    config_parser.add_argument("value")

    result = parser.parse_args(remainder)
    result.offload = True

    return result

def main() -> int:
    brew_offload = BrewOffload(sys.argv)
    return brew_offload.execute()

if __name__ == "__main__":
    exit(main())
