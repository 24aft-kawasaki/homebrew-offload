#!/usr/bin/env python3

import argparse
import json
import logging
import os
import shutil
import subprocess
import sys
from pathlib import Path

class BrewOffload:
    def __init__(self, args: list[str]) -> None:
        self.log = logging.getLogger(__name__)

        self.args = arg_parse(*args)

        self.brew_cellar_path = self.get_brew_cellar_path()
        self.config_path = self.get_brew_prefix_path() / "etc/brew-offload/config.json"
        # TODO: To test, file access must not be called, if original brew is executed.
        # Plese refactor with test codes.
        self.target_path = (DEFAULT_TARGET_PATH := Path.home() / ".offload")
        with open(self.config_path, "rt") as config_file:
            config = json.load(config_file)
        if "offload_cellar" in config:
            self.target_path = Path(config["offload_cellar"])
    
    @staticmethod
    def get_brew_cellar_path() -> Path:
        result = subprocess.run(
            ["brew", "--cellar"],
            capture_output=True, text=True, check=True
        )
        return Path(result.stdout.strip())

    @staticmethod
    def get_brew_prefix_path() -> Path:
        result = subprocess.run(
            ["brew", "--prefix"],
            capture_output=True, text=True, check=True
        )
        return Path(result.stdout.strip())

    def execute(self) -> int:
        if self.args.offload is False:
            return self.execute_original_brew(self.args.original_brew_args)
        elif self.args.subcommand == "add":
            return self.add()
        elif self.args.subcommand == "remove":
            raise NotImplementedError("Remove functionality is not implemented yet.")
        elif self.args.subcommand == "config":
            return self.config()
        return 1
    
    def init_config_file(self) -> int:
        if not self.config_path.exists(follow_symlinks=True):
            self.config_path.touch()
        with open(self.config_path, "r+t") as config_file:
            config = {"offloaded_formulae": []}
            try:
                config = json.load(config_file)
                if "offloaded_formulae" in config:
                    return 0
            except json.JSONDecodeError:
                pass
            config_file.seek(0)
            json.dump(config, config_file)
            config_file.truncate()
        return 0

    
    def add(self) -> int:
        self.init_config_file()
        with open(self.config_path, "r+t") as config_file:
            config = json.load(config_file)
            if self.args.formula in config["offloaded_formulae"]:
                self.log.error(f"Formula '{self.args.formula}' is already offloaded.")
                return 1
            config["offloaded_formulae"].append(self.args.formula)
            config_file.seek(0)
            json.dump(config, config_file)
            config_file.truncate()

        return self.sync()

    def config(self) -> int:
        self.init_config_file()
        with open(self.config_path, "rt") as config_file:
            config = json.load(config_file)
        if self.args.key == "offload_cellar":
            new_offload_cellar = Path(self.args.value)
            old_offload_cellar = self.target_path
            if not new_offload_cellar.absolute():
                self.log.error("Offload cellar path must be absolute.")
                return 1
            new_offload_cellar = new_offload_cellar.absolute()
            if not new_offload_cellar.exists():
                self.log.error("Offload cellar path does not exist.")
                return 1
            config["offload_cellar"] = str(new_offload_cellar)
            self.target_path = new_offload_cellar
        with open(self.config_path, "wt") as config_file:
            json.dump(config, config_file)
        
        self.mv_offload_cellar(new_offload_cellar, old_offload_cellar)

        return 0

    def sync(self) -> int:
        with open(self.config_path, "rt") as config_file:
            config = json.load(config_file)

        # offloading
        for target_formula in config["offloaded_formulae"]:
            src = (self.brew_cellar_path / target_formula).absolute()
            dst = (self.target_path / target_formula).absolute()

            if src.is_symlink() and src.resolve().is_dir():
                continue
            if not src.exists():
                continue
            self.log.info(f"Offloading formula: {target_formula}")
            shutil.copytree(src, dst,
                symlinks=True, dirs_exist_ok=True)
            shutil.rmtree(src)
            os.symlink(dst, src, target_is_directory=True)

        # onloading
        for offloaded in self.target_path.iterdir():
            if offloaded.name in config["offloaded_formulae"]:
                continue
            self.log.info(f"Onloading formula: {offloaded.name}")
            dst = (self.brew_cellar_path / offloaded.name).absolute()
            src = (self.target_path / offloaded.name).absolute()
            dst.unlink()
            shutil.copytree(src, dst, 
                symlinks=True, dirs_exist_ok=True)
            shutil.rmtree(src)

        return 0
    
    def mv_offload_cellar(self, new_cellar: Path, old_cellar: Path) -> int:
        for formula in old_cellar.iterdir():
            src = formula.absolute()
            dst = new_cellar / formula.name
            self.log.info(f"Moving offload cellar formula: {formula.name}")
            shutil.copytree(src, dst)
        with open(self.config_path, "rt") as config_file:
            config = json.load(config_file)
        for formula in config["offloaded_formulae"]:
            symlink = self.brew_cellar_path / formula
            symlink.unlink()
            os.symlink(new_cellar / formula, symlink, target_is_directory=True)
        for formula in old_cellar.iterdir():
            shutil.rmtree(formula.absolute())
        return 0

    def execute_original_brew(self, original_brew_args: list[str]) -> int:
        completedProcess = subprocess.run(
            ["brew"] + original_brew_args,
            stdout=None, stderr=None
        )

        return completedProcess.returncode

        

def arg_parse(*args: str) -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    
    parser.add_argument("wrapped")
    parser.add_argument("remainder", nargs=argparse.REMAINDER)
    namespace = parser.parse_args(args[1:])
    if namespace.wrapped == "wrapped":
        parser = argparse.ArgumentParser(prog="brew")
        parser.add_argument("offload")
        parser.add_argument("remainder", nargs=argparse.REMAINDER)
        namespace_offload = parser.parse_args(namespace.remainder)
        if namespace_offload.offload == "offload":
            prog = "brew offload"
        else:
            result = argparse.Namespace()
            result.offload = False
            result.original_brew_args = namespace.remainder
            return result
    else:
        prog = "brew-offload"
        namespace_offload = argparse.Namespace()
        namespace_offload.remainder = args[1:]

    parser = argparse.ArgumentParser(prog=prog)
    subparsers = parser.add_subparsers(title="subcommands")
    add_parser = subparsers.add_parser("add")
    add_parser.set_defaults(subcommand="add")
    add_parser.add_argument("formula")
    remove_parser = subparsers.add_parser("remove")
    remove_parser.set_defaults(subcommand="remove")
    remove_parser.add_argument("formula")
    config_parser = subparsers.add_parser("config")
    config_parser.set_defaults(subcommand="config")
    config_parser.add_argument("key", choices=["offload_cellar"])
    config_parser.add_argument("value")

    result = parser.parse_args(namespace_offload.remainder)
    result.offload = True

    return result

def main() -> int:
    brew_offload = BrewOffload(sys.argv)
    return brew_offload.execute()

if __name__ == "__main__":
    exit(main())
